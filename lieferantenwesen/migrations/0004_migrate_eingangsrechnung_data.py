# Generated by Django 5.2.11 on 2026-03-01 09:58

from decimal import Decimal
from django.db import migrations


# Status mapping from vermietung.Eingangsrechnung to InvoiceIn
STATUS_MAPPING = {
    'NEU': 'DRAFT',
    'PRUEFUNG': 'IN_REVIEW',
    'OFFEN': 'APPROVED',
    'KLAERUNG': 'IN_REVIEW',
    'BEZAHLT': 'PAID',
}


def migrate_eingangsrechnung_to_invoicein(apps, schema_editor):
    """
    Migrate data from vermietung.Eingangsrechnung to lieferantenwesen.InvoiceIn.

    This includes:
    - Invoice header data
    - Cost allocations (EingangsrechnungAufteilung â†’ InvoiceInLine)
    - Document references (update Dokument FK)
    - Status mapping
    """
    # Get models
    Eingangsrechnung = apps.get_model('vermietung', 'Eingangsrechnung')
    EingangsrechnungAufteilung = apps.get_model('vermietung', 'EingangsrechnungAufteilung')
    InvoiceIn = apps.get_model('lieferantenwesen', 'InvoiceIn')
    InvoiceInLine = apps.get_model('lieferantenwesen', 'InvoiceInLine')
    Dokument = apps.get_model('vermietung', 'Dokument')

    # Track migration statistics
    stats = {
        'invoices_migrated': 0,
        'lines_migrated': 0,
        'documents_updated': 0,
    }

    # Create mapping of old invoice IDs to new invoice IDs
    id_mapping = {}

    # Migrate each Eingangsrechnung
    for old_invoice in Eingangsrechnung.objects.all():
        # Calculate amounts from allocations
        aufteilungen = EingangsrechnungAufteilung.objects.filter(eingangsrechnung=old_invoice)
        net_amount = Decimal('0')
        tax_amount = Decimal('0')

        for aufteilung in aufteilungen:
            if aufteilung.nettobetrag:
                net_amount += aufteilung.nettobetrag
                # Calculate VAT from cost type
                kostenart = aufteilung.kostenart2 if aufteilung.kostenart2 else aufteilung.kostenart1
                if kostenart and kostenart.umsatzsteuer_satz:
                    vat_rate = Decimal(kostenart.umsatzsteuer_satz)
                    tax_amount += (aufteilung.nettobetrag * vat_rate / Decimal('100')).quantize(Decimal('0.01'))

        gross_amount = net_amount + tax_amount

        # Map status
        mapped_status = STATUS_MAPPING.get(old_invoice.status, 'DRAFT')

        # Create new InvoiceIn record
        new_invoice = InvoiceIn.objects.create(
            # Header data
            invoice_no=old_invoice.belegnummer,
            invoice_date=old_invoice.belegdatum,
            supplier=old_invoice.lieferant,
            currency='EUR',  # Default currency

            # Amounts
            net_amount=net_amount if net_amount > 0 else None,
            tax_amount=tax_amount if tax_amount > 0 else None,
            gross_amount=gross_amount if gross_amount > 0 else None,

            # Payment data
            due_date=old_invoice.faelligkeit,
            payment_reference=old_invoice.referenznummer or '',

            # Rental-specific fields
            rental_object=old_invoice.mietobjekt,
            service_period_from=old_invoice.leistungszeitraum_von,
            service_period_to=old_invoice.leistungszeitraum_bis,
            subject=old_invoice.betreff or '',
            reference_number=old_invoice.referenznummer or '',
            notes=old_invoice.notizen or '',
            payment_date=old_invoice.zahlungsdatum,
            allocable_to_tenants=old_invoice.umlagefaehig,

            # Status
            status=mapped_status,

            # Audit fields
            created_at=old_invoice.erstellt_am,
            updated_at=old_invoice.geaendert_am,
        )

        # Store ID mapping
        id_mapping[old_invoice.id] = new_invoice.id
        stats['invoices_migrated'] += 1

        # Migrate allocations to line items
        position_no = 1
        for aufteilung in aufteilungen:
            # Get VAT rate from cost type
            kostenart = aufteilung.kostenart2 if aufteilung.kostenart2 else aufteilung.kostenart1
            tax_rate = Decimal('19.00')  # Default
            if kostenart and kostenart.umsatzsteuer_satz:
                tax_rate = Decimal(kostenart.umsatzsteuer_satz)

            # Calculate amounts
            net = aufteilung.nettobetrag or Decimal('0')
            tax = (net * tax_rate / Decimal('100')).quantize(Decimal('0.01'))
            gross = net + tax

            # Create line item
            InvoiceInLine.objects.create(
                invoice=new_invoice,
                position_no=position_no,
                description=aufteilung.beschreibung or kostenart.name if kostenart else 'Position',
                net_amount=net,
                tax_rate=tax_rate,
                tax_amount=tax,
                gross_amount=gross,
                # Cost type allocation
                cost_type_main_line=aufteilung.kostenart1,
                cost_type_sub_line=aufteilung.kostenart2,
            )

            position_no += 1
            stats['lines_migrated'] += 1

    # Update Dokument references
    # Note: We'll handle this in a separate migration after updating the Dokument model
    # For now, just count them
    docs_to_update = Dokument.objects.filter(eingangsrechnung__isnull=False).count()
    stats['documents_to_update'] = docs_to_update

    # Print migration statistics
    print(f"\nData migration completed successfully:")
    print(f"  - Invoices migrated: {stats['invoices_migrated']}")
    print(f"  - Line items created: {stats['lines_migrated']}")
    print(f"  - Documents to update: {stats['documents_to_update']}")
    print(f"\nID mapping created for {len(id_mapping)} invoices.")


def reverse_migration(apps, schema_editor):
    """
    Reverse the migration by deleting all InvoiceIn records that were created
    from Eingangsrechnung (those with rental_object set).
    """
    InvoiceIn = apps.get_model('lieferantenwesen', 'InvoiceIn')
    InvoiceInLine = apps.get_model('lieferantenwesen', 'InvoiceInLine')

    # Delete all invoices that have a rental_object (these came from Eingangsrechnung)
    rental_invoices = InvoiceIn.objects.filter(rental_object__isnull=False)
    line_count = InvoiceInLine.objects.filter(invoice__in=rental_invoices).count()
    invoice_count = rental_invoices.count()

    # Delete lines first (CASCADE will handle this, but explicit for clarity)
    InvoiceInLine.objects.filter(invoice__in=rental_invoices).delete()
    rental_invoices.delete()

    print(f"\nReverse migration completed:")
    print(f"  - Invoices deleted: {invoice_count}")
    print(f"  - Line items deleted: {line_count}")


class Migration(migrations.Migration):

    dependencies = [
        ('lieferantenwesen', '0003_add_rental_fields_to_invoicein'),
        ('vermietung', '0036_add_stellplatzbetrag_field'),
    ]

    operations = [
        migrations.RunPython(
            migrate_eingangsrechnung_to_invoicein,
            reverse_migration,
        ),
    ]
